package psx

import (
	"errors"
	"io"
	"os"
	"slices"

	"github.com/jbreckmckye/psx-license-tool/internal/cdformat"
)

/**
 * The PSX license area format is documented on https://psx-spx.consoledev.net/cdromformat/#system-area-prior-to-volume-descriptors
 *
 * It is constructed of 16 CD-XA Form1 sectors. Data is therefore interleaved with ECC (error correction) data, but the ECC is
 * actually unused
 *
 * ECCs are ignored due to a bug with early versions of Sony's mastering tool. Early discs were burned with hardware like the
 * CDU-920 which didn't understand CD-XA and therefore didn't spot the problem... by the time Sony realised what had happened
 * there were too many games released with "broken" ECCs so they had to support it to be backwards compatible. Therefore the
 * PSX BIOS only reads the first 0x800 (2048) bytes of each sector.
 *
 */

const LICENSE_SECTORS = 16

// EU/US: String is followed repeating 0x00 bytes
var EUR_STRING = [70]byte{0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x4C, 0x69, 0x63, 0x65, 0x6E, 0x73, 0x65, 0x64, 0x20, 0x20, 0x62, 0x79, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x53, 0x6F, 0x6E, 0x79, 0x20, 0x43, 0x6F, 0x6D, 0x70, 0x75, 0x74, 0x65, 0x72, 0x20, 0x45, 0x6E, 0x74, 0x65, 0x72, 0x74, 0x61, 0x69, 0x6E, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x45, 0x75, 0x72, 0x6F, 0x20, 0x70, 0x65, 0x20, 0x20, 0x20}
var USA_STRING = [70]byte{0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x4C, 0x69, 0x63, 0x65, 0x6E, 0x73, 0x65, 0x64, 0x20, 0x20, 0x62, 0x79, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x53, 0x6F, 0x6E, 0x79, 0x20, 0x43, 0x6F, 0x6D, 0x70, 0x75, 0x74, 0x65, 0x72, 0x20, 0x45, 0x6E, 0x74, 0x65, 0x72, 0x74, 0x61, 0x69, 0x6E, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x41, 0x6D, 0x65, 0x72, 0x20, 0x20, 0x69, 0x63, 0x61, 0x20}

// JP: String is followed by repeating 64 byte pattern of 62*0x30, 1*0x0A, 1*0x30 - this continues 31 times (1,984 bytes)
var JP_STRING = [65]byte{0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x4C, 0x69, 0x63, 0x65, 0x6E, 0x73, 0x65, 0x64, 0x20, 0x20, 0x62, 0x79, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x53, 0x6F, 0x6E, 0x79, 0x20, 0x43, 0x6F, 0x6D, 0x70, 0x75, 0x74, 0x65, 0x72, 0x20, 0x45, 0x6E, 0x74, 0x65, 0x72, 0x74, 0x61, 0x69, 0x6E, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x49, 0x6E, 0x63, 0x2E, 0x0A}

func ReadLicense(f *os.File) ([]cdformat.XAForm1Sector, error) {
	sectors := make([]cdformat.XAForm1Sector, LICENSE_SECTORS)

	const CHUNK_SIZE = cdformat.ISO_SECTOR_SIZE

	for i := range LICENSE_SECTORS {
		buffer := make([]byte, CHUNK_SIZE)
		offset := int64(CHUNK_SIZE * i)

		bytesRead, err := f.ReadAt(buffer, offset)
		if err == io.EOF {
			return sectors, errors.New("reached end of file too early, check the path is actually a disc BIN image")
		}
		if bytesRead < CHUNK_SIZE {
			return sectors, errors.New("error reading disc sector, read too few bytes")
		}

		sector, err := cdformat.ParseSectorXAForm1(buffer)
		if err != nil {
			return sectors, err
		}

		sectors[i] = sector
	}

	return sectors, nil
}

func GetLicenseText(license []cdformat.XAForm1Sector) [70]byte {
	sector := license[4]
	return [70]byte(sector.Data[:70])
}

func GetLicenseTMD(license []cdformat.XAForm1Sector) []byte {
	sectors := license[5:]
	var tmd []byte

	for _, sector := range sectors {
		bytes := sector.Data[:]
		tmd = slices.Concat(tmd, bytes)
	}

	// Trim trailing nulls
	lastByte := len(tmd) - 1
	for lastByte >= 0 {
		char := tmd[lastByte]
		if char == 0xFF {
			lastByte--
		} else {
			break
		}
	}

	return tmd
}
